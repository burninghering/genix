<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vessel Simulation</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        #map {
            height: 600px;
        }
    </style>
</head>
<body>
    <div id="map" style="width: 100%; height: 600px;"></div>  <!-- 지도의 크기를 지정 -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>

<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script>
// Leaflet.js 지도를 초기화하는 부분
const map = L.map('map').setView([35.985, 129.560], 14); // 초기 위치 및 줌 레벨 설정

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 18,
    attribution: '© OpenStreetMap contributors'
}).addTo(map);

let vesselState = {};

// 날짜 형식 함수
function formatDateToYYYYMMDDHHMMSS(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}

// 육지 영역을 3개의 다각형으로 정의
const landPolygons = [
    L.polygon([
        [35.986965, 129.557129],
        [35.990537, 129.558800],
        [35.989130, 129.561515],
        [35.985496, 129.557690]
    ]).addTo(map),
    
    L.polygon([
        [35.989777, 129.554763],
        [35.990139, 129.555566],
        [35.989261, 129.556357],
        [35.988910, 129.555822],
    ]).addTo(map),
    
    L.polygon([
        [35.985971, 129.560514],
        [35.982902, 129.553539],
        [35.980280, 129.555223],
        [35.985690, 129.560659],
    ]).addTo(map)
];

// 배가 다닐 수 있는 구간을 다각형으로 정의
const seaRoutePolygon = L.polygon([
    [35.990017, 129.557296],
    [35.985823, 129.552777],
    [35.978084, 129.560113],
    [35.986419, 129.570662]
]).addTo(map);

// 랜덤 범위 값을 생성하는 함수 추가
function generateRandomInRange(min, max) {
    return Math.random() * (max - min) + min;
}

// 육지에 접근하면 반대 방향으로 선박 방향을 바꾸는 함수
function avoidLandArea(state) {
    state.course = (state.course + 180 + Math.random() * 60 - 30) % 360; // 방향을 180도 반전 후 약간 랜덤하게 설정
}

// 선박이 항로 밖에 있을 경우 가장 가까운 경계로 복귀하는 함수
function steerBackToSeaRoute(state) {
    const closestPoint = turf.nearestPointOnLine(
        turf.lineString(seaRoutePolygon.getLatLngs()[0].map(latlng => [latlng.lng, latlng.lat])),
        turf.point([state.longi, state.lati])
    );
    
    // closestPoint가 있는 좌표로 선박의 방향을 조정
    const angleToRoute = Math.atan2(
        closestPoint.geometry.coordinates[1] - state.lati,
        closestPoint.geometry.coordinates[0] - state.longi
    );
    
    state.course = (angleToRoute * 180 / Math.PI + 360) % 360; // 가장 가까운 경계를 향해 방향 설정
}

// 선박이 seaRoutePolygon 내부에 머물도록 복귀시키는 함수
function ensureInsideSeaRoute(state) {
    if (!isInSeaRoute(state.lati, state.longi)) {
        steerBackToSeaRoute(state); // 경계로 즉시 복귀
    }
}


// 선박이 육지 다각형 중 하나에 들어갔는지 확인하는 함수
function isInLandArea(lati, longi) {
    const point = L.latLng(lati, longi);
    return landPolygons.some(polygon => polygon.getBounds().contains(point)); // 다각형 중 하나라도 포함하는지 확인
}

// 랜덤 범위 값을 생성하는 함수
function generateRandomInRange(min, max) {
    return Math.random() * (max - min) + min;
}

// Turf.js를 사용하여 선박이 seaRoutePolygon 내부에 있는지 확인하는 함수
function isInSeaRoute(lati, longi) {
    const point = turf.point([longi, lati]); // 좌표는 [경도, 위도] 순서
    let routeCoordinates = seaRoutePolygon.getLatLngs()[0].map(latlng => [latlng.lng, latlng.lat]);

    // 다각형이 닫혀 있는지 확인하고 첫 좌표와 마지막 좌표가 동일하지 않으면 닫음
    if (routeCoordinates[0][0] !== routeCoordinates[routeCoordinates.length - 1][0] || 
        routeCoordinates[0][1] !== routeCoordinates[routeCoordinates.length - 1][1]) {
        routeCoordinates.push(routeCoordinates[0]);
    }

    const polygon = turf.polygon([routeCoordinates]);
    return turf.booleanPointInPolygon(point, polygon); // Turf.js로 다각형 내부에 있는지 확인
}

// 선박이 seaRoutePolygon 내부에서만 생성되는 함수
function generateVesselWithinSeaRoute() {
    let lati, longi;
    do {
        lati = generateRandomInRange(35.982111, 35.989924); // 임의의 위도 생성
        longi = generateRandomInRange(129.556288, 129.566515); // 임의의 경도 생성
    } while (!isInSeaRoute(lati, longi) || isInLandArea(lati, longi)); // seaRoutePolygon 내에서만 생성
    return { lati, longi };
}


// 선박의 더미 데이터를 생성하는 함수
function generateDummyVesselData(devId) {
    if (!vesselState[devId]) {
        const position = generateVesselWithinSeaRoute(); // seaRoutePolygon 내부에서만 생성
        vesselState[devId] = {
            lati: position.lati,
            longi: position.longi,
            speed: 0.0001, // 속도를 더 낮게 설정
            course: Math.floor(Math.random() * 360), // 랜덤 방향
        };
    }

    let state = vesselState[devId];
    const speedFactor = state.speed / 10000;

    // 현재 방향을 바탕으로 선박 위치 업데이트
    state.lati += speedFactor * Math.cos((state.course * Math.PI) / 180);
    state.longi += speedFactor * Math.sin((state.course * Math.PI) / 180);

    // 선박이 seaRoutePolygon 바깥에 있으면 즉시 복귀
    ensureInsideSeaRoute(state);

    // 선박이 육지 영역에 접근하면 방향을 변경하여 육지 회피
    if (isInLandArea(state.lati, state.longi)) {
        avoidLandArea(state); // 육지를 피하기 위해 방향 변경
    }

    // 속도와 방향을 약간 랜덤하게 조정
    state.speed = Math.max(0.0001, Math.min(0.0005, state.speed)); // 속도를 제한
    state.course = (state.course + Math.random() * 10 - 5 + 360) % 360; // 방향 조정

    return {
        id: devId,
        lati: state.lati,
        longi: state.longi,
        speed: state.speed.toFixed(5), // 속도 조정
        course: state.course.toFixed(0),
        log_datetime: formatDateToYYYYMMDDHHMMSS(new Date()) // 현재 시간을 반환
    };
}

// 선박의 위치를 업데이트하는 함수
function updateVesselPositions() {
    vessels.forEach(vessel => {
        const newVesselData = generateDummyVesselData(vessel.id);
        ensureInsideSeaRoute(newVesselData); // seaRoutePolygon 바깥으로 나가지 않도록 보장
        vessel.marker.setLatLng([newVesselData.lati, newVesselData.longi]); // 마커 위치 업데이트
        vessel.marker.getPopup().setContent(`
            <b>Vessel ${vessel.id}</b><br>
            Lat: ${newVesselData.lati.toFixed(5)}, Lon: ${newVesselData.longi.toFixed(5)}<br>
            Speed: ${newVesselData.speed} km/h, Course: ${newVesselData.course}&deg;<br>
            Time: ${newVesselData.log_datetime}
        `);
    });
}

// 마커를 생성하는 부분
const vessels = [];
for (let i = 1; i <= 50; i++) {
    const vesselData = generateDummyVesselData(i);
    const marker = L.marker([vesselData.lati, vesselData.longi]).addTo(map); // 지도에 마커 추가
    marker.bindPopup(`
        <b>Vessel ${vesselData.id}</b><br>
        Lat: ${vesselData.lati.toFixed(5)}, Lon: ${vesselData.longi.toFixed(5)}<br>
        Speed: ${vesselData.speed} km/h, Course: ${vesselData.course}&deg;<br>
        Time: ${vesselData.log_datetime}
    `);
    vessels.push({ id: i, marker: marker });
}

// 0.5초마다 위치 업데이트
setInterval(updateVesselPositions, 500);



</script>

</body>
</html>
